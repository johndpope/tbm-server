TERMINOLOGY
===========

MailboxKey (mkey): some long hash-like random-looking key that is assigned to a user, and is shared with his connections

AuthKey (auth): A unique key that is assigned to a user that is used to uniquely identify that user.  This is not shared w/ anyone else.  It's like an auth cookie in browser-land.

AmazonSecurityToken (aka token): The security model for access to Amazon resources is via tokens, which are passed by a Token Vending Machine and provide access to select resources.  In this case, it's to an S3 bucket that houses all the videos.  If we wanted to, we could bucket-ize connections but that's a lot of work and management so we count on obscurity for some security. The AmazonSecurityToken is generated by the client using a shared algorithm with the VendingMachine.

ConnectionKey: A key that uniquely identifies a connection from one user to another user.  The proposal is to create the ConnectionKey as a function of the sender MailboxKey and receiver MailboxKey.  This is a non-commuting function, i.e. order is important, so the ConnectionKey from user1->user2 is different from user2->user1.  The space for ConnectionKeys is large, so that it is very sparsely populated, making it difficult for a hacker to guess.

VideoFilename: The filename for a video sent from one user to another.  When the user sends another video, he uses the same VideoFilename. The VideoFilename is generated from the ConnectionKey. 

LatestVideoIdKV: A key value store which holds the VideoId for the latest video uploaded from a sender->receiver. Written only by sender. 

LatestVideoIdKVKey: This is the key used to access the LatestVidoeKV for a particular sender->receiver. It is created from the ConnectionKey

VideoStatusKV: This is a key value store which holds the VideoID as well as the VideoStatus for a particular sender-receiver.

VideoStatusKVKey: This is the key used to access the VideoStatusKV for a particular sender->receiver. It is created fromt the ConnectionKey

VideoId: A unique ID for a video instance.  We could use any unique ID for this, such as a timestamp.  The benefit of using a timestamp is that it naturally includes information about the file age, so we could display in the UI, if we wanted to, that the video was sent x minutes/days ago, and it's sequential.  We use this videoId to make sure meta-data, such as video status, is tied to the correct video instance.

PushToken: In the mobile OS notification model, each program instance in a device has a PushToken which is then used to as a target when sending notifications to the program on that device.


MESSAGING DATABASE high bandwidth.
=================================
 - Each user gets a MailboxKey for themselves as well as the MailboxKey for each of their friends.
 - They put their MailboxKey and their friends MailboxKey through scramble algorithm to get a ConnectionKey one for each direction for each friend.
 - From the ConnectionKey the are able to generate VideoFilename, and Keys to LatestVideoIdKV and VideoStatusKV
   
 Entities in the high bandwidth kv (dynamo db)
   - Two kvs to handle messaging between sender and receiver regarding sent videos
     - LatestVideoIdKV
	   - Written only by the sender
	   - Contains the VideoId for the last video uploaded by the sender which is simply a timestamp
	   - This is always checked by the receiver either when polling or in response to a notification to determine whether the video is indeed later 
	     than the last one received from the sender. 
	 - VideoStatusKV
	   - Written only by the receiver. Note receiver writes the VideoId of the video he is referring to here as well as the status.
	   - Contains
	     - VideoId
		 - VideoStatus: [:Downloaded, :Viewed]
	   - This is checked by the sender when polling to dermine the status of the video. The sender compares VideoId to make sure that the video the receiver is referring to is the last one that was sent by him. Otherwise he ignores status changes for the stale video.   
 
 Sequence of events:     
   - Creating a message
	 - Sender uploads directly to s3 in using VideoFilename.
	 - Sender updates LatestVideoIdKV referenced by LatestVideoIdKVKey) and places the VidoeId he generates (timestamp) for the video there.
	 - Sender calls notification server:
	   - MailboxKey of sender
	   - MailboxKey of receiver
	   - Type: VideoReceived [VideoId]
	 - Sender client maintains record of VideoId of last video sent.
	 
   x Reciever gets notification of NewVideo
     x Notification contains 
	   x MailboxKey of sender.
	   x VideoId.
	   x Type: VideoReceived.
	 x Receiver compares VideoId with VideoId of last video received from sender.
	   x If older then ignore notification.
	   x If newer: 
		   x !! Receiver does not rely on VideoId in notification as definitive as it may be stale.
		   x Read LatestVideoIdKV 
		   x Associate and save that VideoId with the video that will be downloaded.
		   x Download video directly from S3 using VideoFilename
		   x After download complete
			   x Update VideoStatusKV: [VideoId, Status(downloaded)]
			   x Receiver calls notification server:
			     x MailboxKey of receiver
			     x MailboxKey of sender
				 x VideoId
				 x Type: VideoStatusUpdate [downloaded]
       - POSSIBLE RACE CONDITION: (Unlikely) due to fileUpload and VideoIdKV update not being an atomic transaction.
	     - Sender uploads new video.
		 - Before sender can update  LatestVideoIdKV 
		   - Receiver polls or responds to notification for a prior video and downloads the new Video.
		   - Receiver tags this latest download with the old VideoId rather than its correct timestamp.
		 - Effects:
		   - The receiver will receive a notification that he has received a new video. He may view it and then receive another notification that he has received a new video but it will be the same as the old one. 
		   - This is relatively innoccuous, very unlikely, and should resolve itself.
   
   - Receiver views a video
     - Only on the transition from NotViewed to Viewed
       - Update VideoStatusKV: [VideoId, Status(viewed)]
	   - Send notificication for VideoStatusUpdate
	 
   - Receiver polls for new videos
     - Receiver reads LatestVideoIdKV
		 - If newer than latest video downloaded from sender:
		   - Follow same steps as for "If newer:" in "Receiver gets notification" above.
		 - If older do nothing
	   
   - Sender gets notification of VideoStatus
     - Check VideoId in notification.
	   - If same as VideoId for last video sent:
	     - Update UI with new video status.
	   - Otherwise ignore 
   
   - Sender polls for latest video status.
     - Read VideoStatusKV
	 - Follow same steps as for notification of VideoStatus above.
   
   - Things to check by experiment or research:
     - What happens on S3 if a filename is downloaded while in the middle of an upload. 
	 - What happens on S3 if an upload is aborted is the file corrupted?

NOTIFICATION SERVER high bandwidth
=================================
 - Authenticate using shared algorithm for creating and authenticating - large token.
 - Actions
   - This is my mailbox key, notification token, and platform. (create or update)
   - Send a notification to user
	 - User is identified by mailbox key
	 - Message types:
	 	- New video sent [Timestamp]
	 	- Video status updated [Timestamp, Status]
 - Table has
   - MailboxKey
   - PushToken
   - Platform


USER CONNECTIONS DATABASE low bandwidth
=======================================
Sequence of events:
Invite from inviter to invitee
 - Invitee doesn't have app
   - Inviter sends an sms directly to invitee.
   - Inviter tells server about invite.
   - Sms has a weblink to a site of ours which has a link to the store.
   - Invitee downloads
     - Goes through unknown reg
   - Server recognizes connection
   - App goes to same state as InviteeHasApp IsNotFull.
 - InviteeHasApp
   - Is full
     - What happens in this case?
   - Is not full
     - Doesn't want to add inviter
       - Invitee rejects.
       - Inviter gets a notification. 
         - Acknowledges he got the notification in the ui modal and it disappears as does the invite.
     - Wants to add
         - Invitee accepts
         - Both phones go to ui state where connected but no message has been received. 

 - Inviter 
   - Can cancel invite at anytime by the normal process of ClearingTheSquare
   - If cancelled before invitee has seen the invite it looks like he never got one.
   - If cancelled after it looks like a normal entry without any invites.

- Registration unknown user
  - First | Last | Phone
  - Verify phone via sms
  - On verification create 
  - Record has 
     - First, last, phone, userId, authtoken, mailboxkey.
  
- Ways a user record gets in our system
  - Invite
    - Inviter sends sms to a contact in his phonebook.
    - We send the phone, first, last that he sent the sms to back to the server
    - We add missing country code and area code info.
    - We make an invite connection
    - Create the invited user user record in a pending state. 
  - Registration
    - We find or create the user record based on phone number in a pending state
    - We send a loopback sms
    - We compare the code we receive.
    - Make record verified state.
    - Generate an auth token
    - Send it back to the phone.

- If phone looses auth token user has to go through sms loopback verification again.

Entities
  - Users
  - Connections 
    - Invite as state on connections.
  
Scaling this Users|Connections database
  - Will change many orders of magnitude less often than the messaging side
  - We can set a bit in the messaging side which is subject to notification and high frequency polling telling the client to check for changes in the state of connections.