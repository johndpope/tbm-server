TERMINOLOGY
===========

MailboxKey (mkey): some long hash-like random-looking key that is assigned to a user, and is shared with his connections

AuthKey (auth): A unique key that is assigned to a user that is used to uniquely identify that user.  This is not shared w/ anyone else.  It's like an auth cookie in browser-land.

AmazonSecurityToken (aka token): The security model for access to Amazon resources is via tokens, which are passed by a Token Vending Machine and provide access to select resources.  In this case, it's to an S3 bucket that houses all the videos.  If we wanted to, we could bucket-ize connections but that's a lot of work and management so we count on obscurity for some security. The AmazonSecurityToken is generated by the client using a shared algorithm with the VendingMachine.

ConnectionKey: A key that uniquely identifies a connection from one user to another user.  The proposal is to create the ConnectionKey as a function of the sender MailboxKey and receiver MailboxKey.  This is a non-commuting function, i.e. order is important, so the ConnectionKey from user1->user2 is different from user2->user1.  The space for ConnectionKeys is large, so that it is very sparsely populated, making it difficult for a hacker to guess.

PROBLEM with ConnectionKey version 1. A hacker who is friends with two people can send a message to one of those people posing as the other.

SOLUTION: ConnectionKey version 2: Create a unique connection key CKEY which is stored in the connections table. It is passed with friend when client gets friend. Client creates filenames and kv keys using mkeys and connection key as follows: u1->u2 = mkey1-mkey2-ckey.

VideoFilename: The filename for a video sent from one user to another.  When the user sends another video, he uses the same VideoFilename. The VideoFilename is generated from the ConnectionKey.

LatestVideoIdKV: A key value store which holds the VideoId for the latest video uploaded from a sender->receiver. Written only by sender.

LatestVideoIdKVKey: This is the key used to access the LatestVideoKV for a particular sender->receiver. It is created from the ConnectionKey

VideoStatusKV: This is a key value store which holds the VideoID as well as the VideoStatus for a particular sender-receiver.

VideoStatusKVKey: This is the key used to access the VideoStatusKV for a particular sender->receiver. It is created from the ConnectionKey

VideoId: A unique ID for a video instance.  We could use any unique ID for this, such as a timestamp.  The benefit of using a timestamp is that it naturally includes information about the file age, so we could display in the UI, if we wanted to, that the video was sent - minutes/days ago, and it's sequential.  We use this videoId to make sure meta-data, such as video status, is tied to the correct video instance.

PushToken: In the mobile OS notification model, each program instance in a device has a PushToken which is then used to as a target when sending notifications to the program on that device.


MESSAGING DATABASE high bandwidth. (Deprecated because it doesn't handle multiple videos sent. See next section)
=================================
 - Each user gets a MailboxKey for themselves as well as the MailboxKey for each of their friends.
 - They put their MailboxKey and their friends MailboxKey through scramble algorithm to get a ConnectionKey one for each direction for each friend.
 - From the ConnectionKey the are able to generate VideoFilename, and Keys to LatestVideoIdKV and VideoStatusKV

 Entities in the high bandwidth kv (dynamo db)
   - Two kvs to handle messaging between sender and receiver regarding sent videos
     - LatestVideoIdKV
	   - Written only by the sender
	   - Contains the VideoId for the last video uploaded by the sender which is simply a timestamp
	   - This is always checked by the receiver either when polling or in response to a notification to determine whether the video is indeed later
	     than the last one received from the sender.
	 - VideoStatusKV
	   - Written only by the receiver. Note receiver writes the VideoId of the video he is referring to here as well as the status.
	   - Contains
	     - VideoId
		 - VideoStatus: [:Downloaded, :Viewed]
	   - This is checked by the sender when polling to dermine the status of the video. The sender compares VideoId to make sure that the video the receiver is referring to is the last one that was sent by him. Otherwise he ignores status changes for the stale video.

 Sequence of events:
   - Creating a message
	 - Sender uploads directly to s3 in using VideoFilename.
	 - Sender updates LatestVideoIdKV referenced by LatestVideoIdKVKey) and places the VidoeId he generates (timestamp) for the video there.
	 - Sender calls notification server:
	   - MailboxKey of sender
	   - MailboxKey of receiver
	   - Type: VideoReceived [VideoId]
	 - Sender client maintains record of VideoId of last video sent.

   - Reciever gets notification of NewVideo
     - Notification contains
	   - MailboxKey of sender.
	   - VideoId.
	   - Type: VideoReceived.
	 - Receiver compares VideoId with VideoId of last video received from sender.
	   - If older then ignore notification.
	   - If newer:
		   - !! Receiver does not rely on VideoId in notification as definitive as it may be stale.
		   - Read LatestVideoIdKV
		   - Associate and save that VideoId with the video that will be downloaded.
		   - Download video directly from S3 using VideoFilename
		   - After download complete
			   - Update VideoStatusKV: [VideoId, Status(downloaded)]
			   - Receiver calls notification server:
			     - MailboxKey of receiver
			     - MailboxKey of sender
				 - VideoId
				 - Type: VideoStatusUpdate [downloaded]
       - POSSIBLE RACE CONDITION: (Unlikely) due to fileUpload and VideoIdKV update not being an atomic transaction.
	     - Sender uploads new video.
		 - Before sender can update  LatestVideoIdKV
		   - Receiver polls or responds to notification for a prior video and downloads the new Video.
		   - Receiver tags this latest download with the old VideoId rather than its correct timestamp.
		 - Effects:
		   - The receiver will receive a notification that he has received a new video. He may view it and then receive another notification that he has received a new video but it will be the same as the old one.
		   - This is relatively innoccuous, very unlikely, and should resolve itself.

   - Receiver views a video
     - Only on the transition from NotViewed to Viewed
       - Update VideoStatusKV: [VideoId, Status(viewed)]
	   - Send notificication for VideoStatusUpdate

   - Receiver polls for new videos
     - Receiver reads LatestVideoIdKV
		 - If newer than latest video downloaded from sender:
		   - Follow same steps as for "If newer:" in "Receiver gets notification" above.
		 - If older do nothing

   - Sender gets notification of VideoStatus
     - Check VideoId in notification.
	   - If same as VideoId for last video sent:
	     - Update UI with new video status.
	   - Otherwise ignore

   - Sender polls for latest video status.
     - Read VideoStatusKV
	 - Follow same steps as for notification of VideoStatus above.

   - Things to check by experiment or research:
     - What happens on S3 if a filename is downloaded while in the middle of an upload.
	 - What happens on S3 if an upload is aborted is the file corrupted?


MESSAGING DATABASE high bandwidth with send multiple videos
===========================================================
(same) means an aspect of the implementation is the same as messaging protocol above without multiple video capablility.

Entities
--------
  - VideoIdsKV
    - Contains an array of videos sent by the sender
	- Sender appends the id of the latest video that was sent.
	- Receiver reads it and deletes the video id of the video he just uploaded.
  - VideoFilenameKV
    - Unique for each video. Created by using sender and receiver mailbox key as well as videoId
  - VideoStatusKV (same)
    - Written only by the reciever
	- Contains
	  - VideoId
	  - VideoStatus: [:Downloaded, :Viewed]
	- Only refers to the very last video that was downloaded or viewed by the receiver. NOT an array as with VideoIds.


DynamoDb implementation of Entities
-----------------------------------
- Dynamo has the concept of:
  - Tables with a Hash primary key - flat only can query with single hash which always returns 1 item.
  - Tables with a Hash and Range primary key - relational can query with hash as well as range to return a list of matching items.
    - Hash and Range should work great for VideoIdsKV!
	  - Hash is VidoeIdsKVKey created using mboxKeys as before.
	  - Range is VidoeId
	  - Queries can be done to retrieve all VideoIds for a particular VideoIdsKV
	  - Deletions can be done of a single VideoId without having to do a read of all beforehand.
	  - Additions of a VideoId can be done without having to do a read of all beforehand.a
	  - CONCLUSION: There should not be a problem with both receivers and senders reading and writing to the list of videoIds for a particular VideoIdKV!


Change in datascructures on the client
--------------------------------------
- Current
  - Incoming_video_id
  - Incoming_video_status
  - Downloading_video_id
  - Download_retry_count
- Change to
  - Active model for Video relational to Friend via friendId
    - Attributes - FriendId, Status, DownloadRetryCount


Sequence of Events
------------------
- Creating a message
  - Sender uploads file directly to S3 using VideoFilename created by mkeys ckey and VideoId
  - Sender adds videoId to VideoIdsKV (key1=sender_mkey-reciever_mkey, k2=video_id, value=videio_id)
  - Sender calls notification server (same)
  - Sender maintains record of last videoId (same)

- Receiver gets notification of videoReceived
  - Receiver compares videoId with video ids in IncomingVideos
    - If it is older than the oldest videoId ignore the notification. (CLIENT DOES NOT DO THIS)
	    - POTENTIAL PROBLEM:
		  This assumes notifications of videos received will always arrive in the order they were sent.
		  If this is not the case then videos could be dropped.
	- If it is the same as any videoId ignore the notifcation.

	- Otherwise proceed...

  - Receiver adds video object Incoming_Videos
  - Receiver downloads the video directly from S3 (same)
  - Receiver deletes the video from S3
    - POTENTIAL PROBLEM: If this delete fails we will have hanging videos which may never be found and deleted.
	- POSSIBLE SOLUTION: the notification server should have a list or be able to construct a list (though not foolproof) of all
	  videoFilenames. We may in the future have a service which goes through and attemts to delete using that list after some time.
  - Receiver deletes from remoteDb where Hash=VideoIdsKVKey and Range=VideoId (key1=sender_mkey-reciever_mkey, k2=video_id, value=videio_id)
    o if delete from S3 is successful otherwise leave it so we get another attempt to do the delete from S3 with the next poll.
  - After download complete
    - Receiver calls notification server for videoStatus downloaded (same)
  - Receiver updates VideoStatusKV (same)

- UI processing of multiple messages on client
  - See tbm(android)/doc/receive multiple.txt

- Receiver views a video (same)
  - Only on the transition from NotViewed to Viewed
    - Update VideoStatusKV: [VideoId, Status(viewed)]
    - Send notificication for VideoStatusUpdate

- Receiver polls for new videos
 - Receiver reads VideoIdsKV get_all (key1=sender_mkey-reciever_mkey, key2=null)
     - Process VideoIds from oldest to newest.
       - If it is older than the earliest videoId in Incoming_Videos then skip.
   	   - If it is the same as any videoId  in Incoming_Videos then skip
       - Otherwise proceed as for notification above.

- Sender gets notification of VideoStatus (same)
 - Check VideoId in notification.
   - If same as VideoId for last video sent:
     - Update UI with new video status.
   - Otherwise ignore

- Sender polls for latest video status. (same)
 - Read VideoStatusKV get_one (key1=sender_mkey-reciever_mkey)
 - Follow same steps as for notification of VideoStatus above.



NOTIFICATION SERVER high bandwidth
=================================
 - Authenticate using shared algorithm for creating and authenticating - large token.
 - Actions
   - This is my mailbox key, notification token, and platform. (create or update)
   - Send a notification to user
	 - User is identified by mailbox key
	 - Message types:
	 	- New video sent [Timestamp]
	 	- Video status updated [Timestamp, Status]
 - Table has
   - MailboxKey
   - PushToken
   - Platform



USER CONNECTIONS DATABASE low bandwidth (with bench)
=======================================
Since we are adding the bench connections can be simplified or even eliminated.
 - Bench shows
   - List of people you have zazo'd who are not on the front screen because zazo is full.
   - List of ~10 people you text the most who are not on the above list.
   - Link to all other contacts
 - Getting to the bench
   - Tapping plus sign on app square takes you to bench.
   - Tapping an icon in the header takes you to bench (for when all squares are full).
 - Tapping someone on the bench
   - If he is already connected to you
     - Puts the user on your grid with last thumbnail highlights him and you can start messaging.
     - Subs out least zazo'd person on your grid.
   - If he is not in your connected list
     - Sends Name Phone number of invitee to server:
     - Server adds user if doesnt exist
     - Server makes connection
     - Server responds with record of friend.
     - Device_platform indicates whether friend has the app or not.

   - Invitee doesn't have app
     - Inviter sends an sms directly to invitee.
     - Sms has a weblink to a site of ours which has a link to the store.
     - Invitee downloads
       - Goes through unknown reg
     - Server recognizes connection
     - Inviter app ui post sending sms...
       - Suggestion to send a welcome message.
       - Invitee in grid with placeholder for thumbnail.
       - Ability to record and tickle (send another sms or call) from the square.
     - Invitee app ui
       - Square filled with connected inviter and hopefully thumbnail and first message.

   - InviteeHasApp
     - Inviter app ui
       - Back to the home screen with square of person clicked from the bench highlighted
       - Same as connected user just send a message.
     - Actions on receiving a notification for a friend you dont have.
       - Invitee gets message notification.
       - He doesnt recognize friend.
       - He gets friend from server
       - He polls for video
       - Square filled with connected inviter and welcome message.

- Registration unknown user
  - First | Last | Phone
  - Verify phone via sms
  - On verification create
  - Record has
     - First, last, phone, userId, authtoken, mailboxkey.

- Ways a user record gets in our system
  - Invite
    - Inviter sends sms to a contact in his phonebook.
    - We send the phone, first, last that he sent the sms to back to the server
    - We add missing country code and area code info.
    - We make an invite connection
    - Create the invited user user record in a pending state.
  - Registration
    - We find or create the user record based on phone number in a pending state
    - We send a loopback sms
    - We compare the code we receive.
    - Make record verified state.
    - Generate an auth token
    - Send it back to the phone.

- If phone looses auth token user has to go through sms loopback verification again.

Entities
  - Users
  - Connections
    - Invite as state on connections.

Scaling this Users|Connections database
  - Will change many orders of magnitude less often than the messaging side
  - We can set a bit in the messaging side which is subject to notification and high frequency polling telling the client to check for changes in the state of connections.

Corner case implications for client:
- Notification comes in for person you are not connected to. Prompts app to query the server to get latest connections.

HANDLING MORE THAN 8 CONNECTIONS
================================

Bench concept
-------------
- Fewer than 8 users
  - Initiate invite
    - From empty box
    - From link in menu
  - Status of invite
    - In square you initiated from
    - In pending invite list
  - Messaging
    - Always from your field

- More than 8 users
  - Initiate invite
    - From link in menu
    - Substitutes for least used.
  - Status of invite
    - Square that was subbed to
    - From link in menu
  - Messaging
    - Incoming from someone on the bench
      - Replaces least used person on your home screen
    - To someone on your bench
      - Tap the person on your bench
      - takes you to the home screen with him highlighted
      - Replaces least used person on your home screen

- Rules for ranking and subbing bench
  -


DEPRECATED!!!!
USER CONNECTIONS DATABASE low bandwidth Deprecated...
=======================================
Sequence of events:
Invite from inviter to invitee
 - Inviter sends Name Phone number of invitee to server:
   - Server adds user if not there
   - Server makes connection
   - Server responds with record of friend.
   - Device_platform indicates whether friend has the app or not.
   - Connection status indicates state of connection.
 - Invitee doesn't have app
   - Inviter sends an sms directly to invitee.
   - Inviter tells server about invite.
   - Sms has a weblink to a site of ours which has a link to the store.
   - Invitee downloads
     - Goes through unknown reg
   - Server recognizes connection
   - App goes to same state as InviteeHasApp IsNotFull.
 - InviteeHasApp
   - Is full
     - What happens in this case?
   - Is not full
     - Doesn't want to add inviter
       - Invitee rejects.
       - Inviter gets a notification.
         - Acknowledges he got the notification in the ui modal and it disappears as does the invite.
     - Wants to add
         - Invitee accepts
         - Both phones go to ui state where connected but no message has been received.

 - Inviter
   - Can cancel invite at anytime by the normal process of ClearingTheSquare
   - If cancelled before invitee has seen the invite it looks like he never got one.
   - If cancelled after it looks like a normal entry without any invites.

- Registration unknown user
  - First | Last | Phone
  - Verify phone via sms
  - On verification create
  - Record has
     - First, last, phone, userId, authtoken, mailboxkey.

- Ways a user record gets in our system
  - Invite
    - Inviter sends sms to a contact in his phonebook.
    - We send the phone, first, last that he sent the sms to back to the server
    - We add missing country code and area code info.
    - We make an invite connection
    - Create the invited user user record in a pending state.
  - Registration
    - We find or create the user record based on phone number in a pending state
    - We send a loopback sms
    - We compare the code we receive.
    - Make record verified state.
    - Generate an auth token
    - Send it back to the phone.

- If phone looses auth token user has to go through sms loopback verification again.

Entities
  - Users
  - Connections
    - Invite as state on connections.

Scaling this Users|Connections database
  - Will change many orders of magnitude less often than the messaging side
  - We can set a bit in the messaging side which is subject to notification and high frequency polling telling the client to check for changes in the state of connections.